## c_for_tcp开发中的注意事项
1. 如果文件夹名和生成的可执行文件名一致，vscode可能无法找到可执行文件
- 源文件: ./src/sendether/sendether.c，可执行文件: ./bin/senderther，将无法找到可执行文件
2. 如果文件夹中出现空格，编译器中将无法识别到文件夹
3. 在c_for_tcp中，采用src下子文件夹的结构，子文件夹中包含针对该子文件夹的头文件和源文件 -> 因为各个子文件夹的功能0互不联通，所以采用这种结构
4. 如果是在GNU/Linux中编译，使用gcc开发，如果需要指定C语言标准，那么应该使用gnu相关的标准，如gnu99
- gcc -std=gnu99
- 在c_cpp_properties.json中，加入以下，以使显示代码提示功能显示正确
```json
"defines": [
    "__linux__",
    "__x86_64__",
    "_GNU_SOURCE"
],
```


## c开发中的注意事项
1. switch..case..: 如果在不同case中定义同一变量名，会编译无法通过
2. tmp = *(rank + 2 * entity);  // 即使数组是float，仍然以int进行序号访问
3. c90中，注释必须采用/* */；循环用变量必须在循环前声明
4. 函数声明必须要在函数调用之前(无论在main函数中声明或在main函数之外声明均可)
5. 具有文件作用域的变量才能定义链接
6. 对于具有static和文件作用域的变量 -> 只在当前文件可以访问
- 当在static_file.h用static声明一个函数时，该函数在static_file.c中将无法定义该函数
- 在github copilot中提问'c语言中用static修饰函数'，得到的回答应该是错误的
- 当没有引入头文件时，可以通过extern访问其他文件中的外部变量，但是如果该外部变量通过static修饰，则无法访问
- 好的设计可以不需要使用文件作用域变量
7. TODO: 头文件中的变量(和预处理器相关)
8. auto关键字在c++中的用法不同，在c/c++混编中注意避开auto关键字
- auto变量不会自动初始化为0，(如果不进行初始化的话)变量的值是之前占用分配给该变量空间中的任意值
9. static变量虽然会在内存中继续存在至程序结束，但是在vscode调试时见不到该变量(退出static变量存在的函数)
- 因为静态变量和外部变量在程序被载入内存时已执行完毕
- 不能在函数的形参中使用static
10. 外部变量(外部链接的静态变量)
- 自动初始化为0，只能用常量表达式进行初始化
- 作用域是：从声明处到文件结尾
- 生命期：在程序运行中一直存在，因为它们不受限于任何函数，不会在某个函数返回后就消失
11. 关键字static和extern的含义取决于上下文
12. 除非使用static关键字，否则一般函数声明都默认为extern
- 为什么引用外部函数可以不使用extern，而引用外部变量必须使用extern？
因为函数分为声明和定义，而变量只有声明，没有定义
13. 为了使用别的源文件中的函数，可以使用extern声明函数，并且将源文件们一起编译；也可以将函数声明放在头文件中，然后在需要的源文件中包含头文件，这种方法要避免多重定义同一函数名
14. 动态分配(malloc)的内存数量只会增加，除非用free进行释放
- 如果没有释放，那么该内存将在程序结束后才会被释放
- 如果在程序结束前，内存就已经满了，就会出现内存泄漏
15. auto(栈1)、static(栈2)、malloc(堆1)分配在内存三个不同的区域，但是在实际的测试中发现malloc分配的区域和static是相同的地方


## c开发中的数组相关
1. 函数原型可以省略参数名，但是函数定义时不能省略参数名
2. 创建一个指针时，系统只分配了储存指针本身的内存，并未分配储存数据的内存 -> 在使用指针之前，必须先用已分配的地址初始化它
```c
int * pt;    // 未初始化的指针
*pt = 5;         // 严重的错误
```
3. 在多维数组中，必须制定除第一维之外的所有维数 -> 目的是使编译器能够知道数组的伸缩尺度的大小
```c
// 运用c99的变长数组特性
int two_test(int n, int p[][n], int i, int j)
{
    printf("a[i][j] = %d\n", p[1][2]);  // error
}
```
- 对于数组的大小，编译器只能通过使用者得知，所以上面的n如果传递错误，并不会产生编译错误，但是会产生错误的结果
4. 将指针从一种类型强制转换为另一种类型，只改变它的类型，而不改变它的值
```c
char * p = (char *)malloc(sizeof(char));
*p = 'a';
printf("p_init: %c\n", *p);    
printf("(int *)p: %p\n", (int *)p);
printf("(int *)p+7: %p\n", (int *)p+7);
printf("(int *)(p+7): %p\n", (int *)(p+7));
```


## c开发中的寄存器和内存相关
1. 寄存器用来存储局部变量，以加快运行效率；但是有些不能存放在寄存器的局部变会放在栈中
- 没有足够多的寄存器存放所有的局部变量(在X86-64中往往可以满足)
- 有些局部变量是数组或结构，必须通过数组和结构引用来访问
- 要对局部变量使用地址运算符'&'，必须能够为它生成一个地址
- 函数必须将栈上的某些参数传递到另一个函数
- 在修改一个被调用者保存寄存器之前，函数需要保存它的状态
2. i386和X86-64的不同
- i386中，在一次调用函数的过程中，会经常移动栈指针，以修改栈帧的大小；而X86-64中，栈指针只在函数开始时移动一次，以创建栈帧，然后在函数结束时移动一次，以销毁栈帧
3. 当C语言生成的可执行文件在运行时，它主要被加载到内存的以下几个部分：
- 文本段（Text Segment）：这部分存储了程序的所有代码（即机器代码）。这部分内存通常是只读的，以防止程序在运行时修改其自身的代码。
- 数据段（Data Segment）：这部分存储了程序的全局变量和静态变量。数据段又可以分为初始化数据段（存储了初始值的全局和静态变量）和未初始化数据段（存储了没有初始值的全局和静态变量）。
- 堆（Heap）：这部分内存用于动态内存分配，如C语言的malloc和free函数所使用的内存。
- 栈（Stack）：这部分内存用于存储局部变量和函数调用的信息。
4. 在汇编语言中，.LC2(%rip)是一种寻址方式，称为RIP相对寻址。
- 这里的%rip是指令指针寄存器（Instruction Pointer Register），在64位系统中，它被称为RIP（Register Instruction Pointer）。RIP寄存器存储着下一条要执行的指令的地址。
- .LC2是一个标签，通常用于标识数据或代码的位置。
- .LC2(%rip)表示的是从当前指令的下一条指令开始，到标签.LC2的相对偏移。这种寻址方式常用于Position Independent Code（位置无关代码），例如动态链接库或者PIE（Position Independent Executable，位置无关可执行文件）。
- 简单来说，.LC2(%rip)就是用来获取标签.LC2的位置的一种方式。


## 一个比较完整的编译过程
<!-- src: main.c sum.c，main.c中使用了sum.c中的函数定义  -->
1. 生成预编译文件，将宏定义等信息进行展开（使用预编译器cpp）
``` bash
cpp main.c main.i
cpp sum.c sum.i
```
2. 将预编译文件转换为汇编文件（使用编译器cc）
``` bash
# cc main.i -o main.s  # 如果main中没有include "sum.c"，这么转换会报错
cc main.i sum.i -o main.s
# cc sum.i -o sum.s  # undefined reference to `main'
```
3. 将汇编文件翻译成一个可重定位目标文件（使用汇编器as）
``` bash
# as main.s -o main.o  # 失败
```